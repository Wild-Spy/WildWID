<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>WIDLoggerV2Test: Libs/eeprom_driver.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">WIDLoggerV2Test
   &#160;<span id="projectnumber">V2.1</span>
   </div>
   <div id="projectbrief">Wireless ID Datalogger with GSM</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Libs/eeprom_driver.c File Reference</div>  </div>
</div>
<div class="contents">

<p>XMEGA EEPROM driver source file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="eeprom__driver_8h_source.html">eeprom_driver.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae24151bc22dbe82a3f53cb1e0177f95a"></a><!-- doxytag: member="eeprom_driver.c::ReadEEPROM" ref="ae24151bc22dbe82a3f53cb1e0177f95a" args="(uint8_t *Data, uint8_t Length, uint16_t Address)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReadEEPROM</b> (uint8_t *Data, uint8_t Length, uint16_t Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ef15a8fa903eacb40687cc0393466a5"></a><!-- doxytag: member="eeprom_driver.c::WriteEEPROM" ref="a3ef15a8fa903eacb40687cc0393466a5" args="(uint8_t *Data, uint8_t Length, uint16_t Address)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteEEPROM</b> (uint8_t *Data, uint8_t Length, uint16_t Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a40b837a691492c4e56751386efeeac44">EEPROM_WriteByte</a> (uint8_t pageAddr, uint8_t byteAddr, uint8_t value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one byte to EEPROM using IO mapping.  <a href="#a40b837a691492c4e56751386efeeac44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#af728405f1c2399ed3ba4ab6d935ddae4">EEPROM_ReadByte</a> (uint8_t pageAddr, uint8_t byteAddr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte from EEPROM using IO mapping.  <a href="#af728405f1c2399ed3ba4ab6d935ddae4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a5af1fa68cc2ab8d1e339ba2042fecbe5">EEPROM_WaitForNVM</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for any NVM access to finish, including EEPROM.  <a href="#a5af1fa68cc2ab8d1e339ba2042fecbe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a11d41712860898672912ae4960a4cde7">EEPROM_FlushBuffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush temporary EEPROM page buffer.  <a href="#a11d41712860898672912ae4960a4cde7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a6417f17aaa15ca28b68b81f6751ee7ea">EEPROM_LoadByte</a> (uint8_t byteAddr, uint8_t value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load single byte into temporary page buffer.  <a href="#a6417f17aaa15ca28b68b81f6751ee7ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a15832acf632fb92cc92c2ab14eb5d57a">EEPROM_LoadPage</a> (const uint8_t *values)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load entire page into temporary EEPROM page buffer.  <a href="#a15832acf632fb92cc92c2ab14eb5d57a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#aa95a711f0db0a957c7b0200d7a3da48b">EEPROM_AtomicWritePage</a> (uint8_t pageAddr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write already loaded page into EEPROM.  <a href="#aa95a711f0db0a957c7b0200d7a3da48b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a37cfa01aaf0f3951a5d65fc9c8f786ba">EEPROM_ErasePage</a> (uint8_t pageAddr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase EEPROM page.  <a href="#a37cfa01aaf0f3951a5d65fc9c8f786ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#a40ea1d62748d71221765b0b0cafd2f56">EEPROM_SplitWritePage</a> (uint8_t pageAddr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write (without erasing) EEPROM page.  <a href="#a40ea1d62748d71221765b0b0cafd2f56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom__driver_8c.html#ace2c264aeffb8214c1cbf0269b8243e2">EEPROM_EraseAll</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase entire EEPROM memory.  <a href="#ace2c264aeffb8214c1cbf0269b8243e2"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>XMEGA EEPROM driver source file. </p>
<p>This file contains the function implementations for the XMEGA EEPROM driver.</p>
<p>The driver is not intended for size and/or speed critical code, since most functions are just a few lines of code, and the function call overhead would decrease code performance. The driver is intended for rapid prototyping and documentation purposes for getting started with the XMEGA EEPROM module.</p>
<p>For size and/or speed critical code, it is recommended to copy the function contents directly into your application instead of making a function call.</p>
<dl class="user"><dt><b>Application note:</b></dt><dd>AVR1315: Accessing the XMEGA EEPROM</dd></dl>
<dl class="user"><dt><b>Documentation</b></dt><dd>For comprehensive code documentation, supported compilers, compiler settings and supported devices see readme.html</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br/>
 Support email: <a href="mailto:avr@atmel.com">avr@atmel.com</a></dd></dl>
<dl class="rcs"><dt><b>Revision:</b></dt><dd>1569 </dd></dl>
<dl class="rcs"><dt><b>Date:</b></dt><dd>2008-04-22 13:03:43 +0200 (ti, 22 apr 2008) </dd></dl>
<p><br/>
</p>
<p>Copyright (c) 2008, Atmel Corporation All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>3. The name of ATMEL may not be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa95a711f0db0a957c7b0200d7a3da48b"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_AtomicWritePage" ref="aa95a711f0db0a957c7b0200d7a3da48b" args="(uint8_t pageAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_AtomicWritePage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pageAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write already loaded page into EEPROM. </p>
<p>This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.</p>
<p>As this is an atomic write, the page in EEPROM will be erased automatically before writing. Note that only the page buffer locations that have been loaded will be used when writing to EEPROM. Page buffer locations that have not been loaded will be left untouched in EEPROM.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pageAddr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace2c264aeffb8214c1cbf0269b8243e2"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_EraseAll" ref="ace2c264aeffb8214c1cbf0269b8243e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_EraseAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase entire EEPROM memory. </p>
<p>This function erases the entire EEPROM memory block to 0xFF. </p>

</div>
</div>
<a class="anchor" id="a37cfa01aaf0f3951a5d65fc9c8f786ba"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_ErasePage" ref="a37cfa01aaf0f3951a5d65fc9c8f786ba" args="(uint8_t pageAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_ErasePage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pageAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase EEPROM page. </p>
<p>This function erases one EEPROM page, so that every location reads 0xFF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pageAddr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11d41712860898672912ae4960a4cde7"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_FlushBuffer" ref="a11d41712860898672912ae4960a4cde7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_FlushBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush temporary EEPROM page buffer. </p>
<p>This function flushes the EEPROM page buffers. This function will cancel any ongoing EEPROM page buffer loading operations, if any. This function also works for memory mapped EEPROM access.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The EEPROM write operations will automatically flush the buffer for you. </dd></dl>

</div>
</div>
<a class="anchor" id="a6417f17aaa15ca28b68b81f6751ee7ea"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_LoadByte" ref="a6417f17aaa15ca28b68b81f6751ee7ea" args="(uint8_t byteAddr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_LoadByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load single byte into temporary page buffer. </p>
<p>This function loads one byte into the temporary EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes. Also, if multiple bytes are loaded into the same location, they will be ANDed together, thus 0x55 and 0xAA will result in 0x00 in the buffer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only one page buffer exist, thus only one page can be loaded with data and programmed into one page. If data needs to be written to different pages, the loading and writing needs to be repeated.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">byteAddr</td><td>EEPROM Byte address, between 0 and EEPROM_PAGESIZE. </td></tr>
    <tr><td class="paramname">value</td><td>Byte value to write to buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15832acf632fb92cc92c2ab14eb5d57a"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_LoadPage" ref="a15832acf632fb92cc92c2ab14eb5d57a" args="(const uint8_t *values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_LoadPage </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load entire page into temporary EEPROM page buffer. </p>
<p>This function loads an entire EEPROM page from an SRAM buffer to the EEPROM page buffers. If memory mapped EEPROM is enabled, this function will not work. Make sure that the buffer is flushed before starting to load bytes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only the lower part of the address is used to address the buffer. Therefore, no address parameter is needed. In the end, the data is written to the EEPROM page given by the address parameter to the EEPROM write page operation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Pointer to SRAM buffer containing an entire page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af728405f1c2399ed3ba4ab6d935ddae4"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_ReadByte" ref="af728405f1c2399ed3ba4ab6d935ddae4" args="(uint8_t pageAddr, uint8_t byteAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t EEPROM_ReadByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pageAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byteAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read one byte from EEPROM using IO mapping. </p>
<p>This function reads one byte from EEPROM using IO-mapped access. If memory mapped EEPROM is enabled, this function will not work.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pageAddr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
    <tr><td class="paramname">byteAddr</td><td>EEPROM Byte address, between 0 and EEPROM_PAGESIZE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Byte value read from EEPROM. </dd></dl>

</div>
</div>
<a class="anchor" id="a40ea1d62748d71221765b0b0cafd2f56"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_SplitWritePage" ref="a40ea1d62748d71221765b0b0cafd2f56" args="(uint8_t pageAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_SplitWritePage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pageAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write (without erasing) EEPROM page. </p>
<p>This function writes the contents of an already loaded EEPROM page buffer into EEPROM memory.</p>
<p>As this is a split write, the page in EEPROM will _not_ be erased before writing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pageAddr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5af1fa68cc2ab8d1e339ba2042fecbe5"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_WaitForNVM" ref="a5af1fa68cc2ab8d1e339ba2042fecbe5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_WaitForNVM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for any NVM access to finish, including EEPROM. </p>
<p>This function is blcoking and waits for any NVM access to finish, including EEPROM. Use this function before any EEPROM accesses, if you are not certain that any previous operations are finished yet, like an EEPROM write. </p>

</div>
</div>
<a class="anchor" id="a40b837a691492c4e56751386efeeac44"></a><!-- doxytag: member="eeprom_driver.c::EEPROM_WriteByte" ref="a40b837a691492c4e56751386efeeac44" args="(uint8_t pageAddr, uint8_t byteAddr, uint8_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROM_WriteByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pageAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byteAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write one byte to EEPROM using IO mapping. </p>
<p>This function writes one byte to EEPROM using IO-mapped access. If memory mapped EEPROM is enabled, this function will not work. This functiom will cancel all ongoing EEPROM page buffer loading operations, if any.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pageAddr</td><td>EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE </td></tr>
    <tr><td class="paramname">byteAddr</td><td>EEPROM Byte address, between 0 and EEPROM_PAGESIZE. </td></tr>
    <tr><td class="paramname">value</td><td>Byte value to write to EEPROM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 3 2011 13:09:38 for WIDLoggerV2Test by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
